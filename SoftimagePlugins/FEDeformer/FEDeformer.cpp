// FEDeformer Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Sep 11 15:05:16 UTC+0100 2012 by Helge Mathee
// 
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>
#include <xsi_customproperty.h>
#include <xsi_ppglayout.h>
#include <xsi_menu.h>
#include <xsi_selection.h>
#include <vector>

// Fabric Engine Includes
#include <FabricEngine/Core.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
  ID_IN_entryFunction = 0,
  ID_IN_sourceCode = 1,
  ID_IN_scalar = 2,
  ID_IN_vec = 3,
  ID_IN_quat = 4,
  ID_G_100 = 100,
  ID_G_101 = 101,
  ID_G_102 = 102,
  ID_G_103 = 103,
  ID_OUT_result = 200,
  ID_TYPE_CNS = 400,
  ID_STRUCT_CNS,
  ID_CTXT_CNS,
  ID_UNDEF = ULONG_MAX
};

XSI::CStatus Register_FEDeformer( XSI::PluginRegistrar& in_reg );

using namespace XSI; 

struct FEDeformerUserData {
  FabricEngine::Core::DGNode resultNode;
  FabricEngine::Core::DGOperator op;
  FabricEngine::Core::DGBinding binding;
  bool valid;
  std::string entryFunction;
  std::string sourceCode;
};

// static attributes
FabricEngine::Core::Client gClient;
std::vector<FabricEngine::Core::DGNode> gScalarNodes;
std::vector<FabricEngine::Core::DGNode> gVecNodes;
std::vector<FabricEngine::Core::DGNode> gQuatNodes;
ULONG gInstanceCount = 0;

std::string replaceStdString(std::string input, std::string search, std::string replacement)
{
  std::string::size_type pos = input.find(search, 0); 
  int intLengthSearch = search.length(); 
  int intLengthReplacment = replacement.length(); 

  while(std::string::npos != pos) 
  { 
    input.replace(pos, intLengthSearch, replacement); 
    pos = input.find(search, pos + intLengthReplacment); 
  } 

  return input; 
}

CStatus registerType(std::string name, FEDeformerUserData * usrData, size_t memberCount, const FabricEngine::Core::RTStructMemberInfo * members)
{
  std::string cpDir = getenv("FABRIC_CREATIONPLATFORM_DIR");
  if(cpDir.length() == 0)
  {
    Application().LogMessage(L"Environment variable FABRIC_CREATIONPLATFORM_DIR not defined!", siErrorMsg);
    return CStatus::Unexpected;
  }

  // load the types
  std::string mathDir = cpDir + "\\Python\\SceneGraph\\RT\\Math\\";
  std::string klPath;
  FILE * klFile = NULL;

  // math
  klPath = mathDir + name + ".kl";
  klFile = fopen(klPath.c_str(), "rb");
  if(klFile == NULL)
  {
    std::string message = "KL file for "+name+" not found!";
    Application().LogMessage(message.c_str(), siErrorMsg);
    return CStatus::Unexpected;
  }
  else
  {
    fseek(klFile, 0, SEEK_END);
    size_t size = ftell(klFile);
    rewind(klFile);
    char * sourceCodeChars = (char *)malloc(size+1);
    sourceCodeChars[size] = '\0';
    fread(sourceCodeChars, sizeof(char), size, klFile);
    fclose(klFile);

    std::string sourceCode = replaceStdString(sourceCodeChars, "REPORTWARNINGS", "false");

    try
    {
      FabricEngine::Core::RegisterStruct(
        gClient,
        name.c_str(),
        memberCount,
        members,
        std::string(name+".kl").c_str(),
        sourceCode.c_str()
      );
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }

    free(sourceCodeChars);
  }

  return CStatus::OK;
}

CStatus initFabricEngineClient(FEDeformerUserData * usrData)
{
  // check if we have the necessary environment variables
  if(gInstanceCount == 0)
  {
    // create the client
    gClient = FabricEngine::Core::Client(true);

    // define type members
    FabricEngine::Core::RTStructMemberInfo Vec3Members[3] = {
      { "x", "Float32" },
      { "y", "Float32" },
      { "z", "Float32" }
    };
    FabricEngine::Core::RTStructMemberInfo RotationOrderMembers[1] =
    {
      { "order", "Integer" }
    };
    FabricEngine::Core::RTStructMemberInfo Mat33Members[3] =
    {
      { "row0", "Vec3" },
      { "row1", "Vec3" },
      { "row2", "Vec3" }
    };
    FabricEngine::Core::RTStructMemberInfo EulerMembers[4] =
    {
      { "x", "Scalar" },
      { "y", "Scalar" },
      { "z", "Scalar" },
      { "ro", "RotationOrder" }
    };
    FabricEngine::Core::RTStructMemberInfo QuatMembers[2] =
    {
      { "v", "Vec3" },
      { "w", "Float32" }
    };

    // register all types
    registerType("Math", usrData, 0, NULL);
    registerType("Vec3", usrData, 3, Vec3Members);
    registerType("RotationOrder", usrData, 1, RotationOrderMembers);
    registerType("Mat33", usrData, 3, Mat33Members);
    registerType("Euler", usrData, 4, EulerMembers);
    registerType("Quat", usrData, 2, QuatMembers);

    // create all of the nodes
    for(size_t i=1;i<11;i++)
    {
      // create the numbered names
      CString scalarName = L"scalar"+CString(LONG(i));
      CString vecName = L"vec"+CString(LONG(i));
      CString quatName = L"quat"+CString(LONG(i));

      // create the nodes
      FabricEngine::Core::DGNode scalarNode(gClient, scalarName.GetAsciiString());
      FabricEngine::Core::DGNode vecNode(gClient, vecName.GetAsciiString());
      FabricEngine::Core::DGNode quatNode(gClient, quatName.GetAsciiString());

      // define the members on the node
      scalarNode.addMember("data", "Float32");
      vecNode.addMember("data", "Vec3");
      quatNode.addMember("data", "Quat");

      // put them into the static arrays
      gScalarNodes.push_back(scalarNode);
      gVecNodes.push_back(vecNode);
      gQuatNodes.push_back(quatNode);
    }
  }

  // create the result node
  usrData->resultNode = FabricEngine::Core::DGNode(gClient, "result");
  usrData->resultNode.addMember("data", "Vec3");

  // create all of the nodes
  for(size_t i=0;i<10;i++)
  {
    // create the numbered names
    CString scalarName = L"scalar"+CString(LONG(i+1));
    CString vecName = L"vec"+CString(LONG(i+1));
    CString quatName = L"quat"+CString(LONG(i+1));

    // setup dependencies
    usrData->resultNode.setDependency(scalarName.GetAsciiString(), gScalarNodes[i]);
    usrData->resultNode.setDependency(vecName.GetAsciiString(), gVecNodes[i]);
    usrData->resultNode.setDependency(quatName.GetAsciiString(), gQuatNodes[i]);
  }

  // create the operator
  usrData->valid = false;
  CString opName = L"operator"+CString(LONG(gInstanceCount));
  usrData->op = FabricEngine::Core::DGOperator(gClient, opName.GetAsciiString());

  // create the parameterlayout
  char const *parameterLayout[32] = { 
    "self.index",
    "scalar1.data<>", 
    "scalar2.data<>", 
    "scalar3.data<>", 
    "scalar4.data<>", 
    "scalar5.data<>", 
    "scalar6.data<>", 
    "scalar7.data<>", 
    "scalar8.data<>", 
    "scalar9.data<>", 
    "scalar10.data<>", 
    "vec1.data<>", 
    "vec2.data<>", 
    "vec3.data<>", 
    "vec4.data<>", 
    "vec5.data<>", 
    "vec6.data<>", 
    "vec7.data<>", 
    "vec8.data<>", 
    "vec9.data<>", 
    "vec10.data<>", 
    "quat1.data<>", 
    "quat2.data<>", 
    "quat3.data<>", 
    "quat4.data<>", 
    "quat5.data<>", 
    "quat6.data<>", 
    "quat7.data<>", 
    "quat8.data<>", 
    "quat9.data<>", 
    "quat10.data<>", 
    "self.data"
  };

  // create the binding and append it
  FabricEngine::Core::DGBinding binding(
    usrData->op,
    32,
    parameterLayout
  );
  usrData->binding = binding;
  usrData->resultNode.appendBinding( binding );

  return CStatus::OK;
}

SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
  in_reg.PutAuthor(L"Helge Mathee");
  in_reg.PutName(L"FE Deformer Plugin");
  in_reg.PutVersion(1,0);

  Register_FEDeformer( in_reg );
	in_reg.RegisterProperty(L"FESourceCode");
	in_reg.RegisterMenu(siMenuTbGetPropertyID,L"FESourceCode_Menu",false,false);

  return CStatus::OK;
}

SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
  CString strPluginName;
  strPluginName = in_reg.GetName();
  Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
  return CStatus::OK;
}

CStatus Register_FEDeformer( PluginRegistrar& in_reg )
{
  ICENodeDef nodeDef;
  nodeDef = Application().GetFactory().CreateICENodeDef(L"FEDeformer",L"FEDeformer");

  CStatus st;
  st = nodeDef.PutColor(73,143,187);
  st.AssertSucceeded( ) ;

  st = nodeDef.PutThreadingModel(XSI::siICENodeSingleThreading);
  st.AssertSucceeded( ) ;

  // Add input ports and groups.
  st = nodeDef.AddPortGroup(ID_G_100);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddPortGroup(ID_G_101, 1, 10);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddPortGroup(ID_G_102, 1, 10);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddPortGroup(ID_G_103, 1, 10);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_entryFunction,ID_G_100,siICENodeDataString,siICENodeStructureSingle,siICENodeContextSingleton,L"entryFunction",L"entryFunction",CValue(),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_sourceCode,ID_G_100,siICENodeDataString,siICENodeStructureSingle,siICENodeContextSingleton,L"sourceCode",L"sourceCode",CValue(),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_scalar,ID_G_101,siICENodeDataFloat,siICENodeStructureSingle,siICENodeContextAny,L"scalar",L"scalar",0,CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_vec,ID_G_102,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextAny,L"vec",L"vec",MATH::CVector3f(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_quat,ID_G_103,siICENodeDataQuaternion,siICENodeStructureSingle,siICENodeContextAny,L"quat",L"quat",MATH::CQuaternionf(1.0,1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  // Add output ports.
  st = nodeDef.AddOutputPort(ID_OUT_result,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextComponent0D,L"result",L"result",ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
  nodeItem.PutCategories(L"Fabric Engine");

  return CStatus::OK;
}


SICALLBACK FEDeformer_Evaluate( ICENodeContext& in_ctxt )
{
  // check if we have a client
  if(gInstanceCount == 0)
    return CStatus::OK;

  // ensure to have a valid userdata
  CValue val = in_ctxt.GetUserData();
  FEDeformerUserData * usrData = (FEDeformerUserData*)(CValue::siPtrType)val;
  if(usrData == NULL)
    return CStatus::OK;

  // check the operator
  std::string entryFunction = CDataArrayString(in_ctxt, ID_IN_entryFunction)[0].GetAsciiString();
  std::string sourceCode = CDataArrayString(in_ctxt, ID_IN_sourceCode)[0].GetAsciiString();
  if(usrData->entryFunction != entryFunction || usrData->sourceCode != sourceCode || !usrData->valid)
  {
    usrData->entryFunction = entryFunction;
    usrData->sourceCode = sourceCode;

    sourceCode = "require Vec3;require Quat;" + sourceCode;

    std::string paramList = "Index index, io Scalar scalar1<>, io Scalar scalar2<>, io Scalar scalar3<>, io Scalar scalar4<>, io Scalar scalar5<>,"; 
    paramList += " io Scalar scalar6<>, io Scalar scalar7<>, io Scalar scalar8<>, io Scalar scalar9<>, io Scalar scalar10<>,"; 
    paramList += " io Vec3 vec1<>, io Vec3 vec2<>, io Vec3 vec3<>, io Vec3 vec4<>, io Vec3 vec5<>,"; 
    paramList += " io Vec3 vec6<>, io Vec3 vec7<>, io Vec3 vec8<>, io Vec3 vec9<>, io Vec3 vec10<>,"; 
    paramList += " io Quat quat1<>, io Quat quat2<>, io Quat Quat<>, io Quat quat4<>, io Quat quat5<>,"; 
    paramList += " io Quat quat6<>, io Quat quat7<>, io Quat quat8<>, io Quat quat9<>, io Quat quat10<>,"; 
    paramList += " io Vec3 result";
    
    sourceCode = replaceStdString(sourceCode, "$PARAMS", paramList);

    // remove the binding if required
    std::string opName = usrData->op.getName().getStdString()+".kl";
    usrData->op.setFilename(opName.c_str());
    usrData->op.setSourceCode(sourceCode.c_str());
    usrData->op.setEntryPoint(entryFunction.c_str());
    usrData->valid = true;

    // first check the dgnode
    try
    {
      FabricEngine::Core::String errors = usrData->resultNode.getErrors();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }

    // then check the binding
    try
    {
      FabricEngine::Core::String errors = usrData->binding.getErrors();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }

    // check for errors
    try
    {
      FabricEngine::Core::String errors = usrData->op.getErrors();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
      FabricEngine::Core::String diagnostics = usrData->op.getDiagnostics();
      if(diagnostics.isValid())
      {
        Application().LogMessage(L"FE Errors: "+CString(diagnostics.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }
  }

  // ensure we don't run this on empty point clouds
  if(in_ctxt.GetNumberOfElementsToProcess() == 0)
    return CStatus::OK;

  // The current output port being evaluated...
  ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );
  
  switch( out_portID )
  {    
    case ID_OUT_result :
    {
      // Get the output port array ...      
      CDataArrayVector3f outData( in_ctxt );
      uint32_t outSize = in_ctxt.GetNumberOfElementsToProcess();
	    if(outSize == 0)
		    return CStatus::OK;

      // get the number of input data
      ULONG numScalars = 0;
      in_ctxt.GetGroupInstanceCount(ID_G_101, numScalars);
      ULONG numVecs = 0;
      in_ctxt.GetGroupInstanceCount(ID_G_102, numVecs);
      ULONG numQuats = 0;
      in_ctxt.GetGroupInstanceCount(ID_G_103, numQuats);

      // copy all scalar data
      for(ULONG i=0;i<numScalars;i++)
      {
        CDataArrayFloat data( in_ctxt, ID_IN_scalar, i);
        uint32_t inSize = data.IsConstant() ? 1 : data.GetCount();
        if(inSize == 0)
          continue;
        gScalarNodes[i].setSize(inSize);
        gScalarNodes[i].setMemberAllSlicesData("data", sizeof(float) * inSize, &data[0]);
      }

      // copy all vector data
      for(ULONG i=0;i<numVecs;i++)
      {
        CDataArrayVector3f data( in_ctxt, ID_IN_vec, i);
        uint32_t inSize = data.IsConstant() ? 1 : data.GetCount();
        if(inSize == 0)
          continue;
        gVecNodes[i].setSize(inSize);
        gVecNodes[i].setMemberAllSlicesData("data", sizeof(float) * 3 * inSize, &data[0]);
      }

      // copy all quaternion data
      for(ULONG i=0;i<numQuats;i++)
      {
        CDataArrayQuaternionf data( in_ctxt, ID_IN_quat, i);
        uint32_t inSize = data.IsConstant() ? 1 : data.GetCount();
        if(inSize == 0)
          continue;
        gQuatNodes[i].setSize(inSize);
        gQuatNodes[i].setMemberAllSlicesData("data", sizeof(float) * 4 * inSize, &data[0]);
      }

      // evaluate the node
      usrData->resultNode.setSize(outSize);
      if(usrData->valid)
      {
        try
        {
          usrData->resultNode.evaluate();
        }
        catch(FabricEngine::Core::Exception e)
        {
          std::string message = e.getStdString();
          Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
          usrData->valid = false;
        }
      }

      // copy the data out
      usrData->resultNode.getMemberAllSlicesData("data", sizeof(float) * 3 * outSize, &outData[0]);
    }
    break;
  };
  
  return CStatus::OK;
}

SICALLBACK FEDeformer_Init( CRef& in_ctxt )
{
  Context ctxt( in_ctxt );

  // allocate userdata
  FEDeformerUserData * usrData = new FEDeformerUserData();

  // check we have a client
  if(CStatus::OK != initFabricEngineClient(usrData))
    return CStatus::Unexpected;

  CValue val = (CValue::siPtrType) usrData;
  ctxt.PutUserData( val );

  gInstanceCount++;

  return CStatus::OK;
}

SICALLBACK FEDeformer_Term( CRef& in_ctxt )
{
  Context ctxt( in_ctxt );

  CValue val = ctxt.GetUserData();
  FEDeformerUserData * usrData = (FEDeformerUserData*)(CValue::siPtrType)val;
  if(usrData != NULL)
  {
    usrData->resultNode = FabricEngine::Core::DGNode();
    usrData->op = FabricEngine::Core::DGOperator();
    usrData->binding = FabricEngine::Core::DGBinding();
    delete(usrData);
  }

  gInstanceCount--;

  if(gInstanceCount == 0)
  {
    gScalarNodes.clear();
    gVecNodes.clear();
    gQuatNodes.clear();
    gClient = FabricEngine::Core::Client();
    FabricEngine::Core::Finalize();
  }

  return CStatus::OK;
}

SICALLBACK FESourceCode_Define( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

  oCustomProperty.AddParameter(L"EntryFunction",CValue::siString,siPersistable,L"",L"",L"myDeformer",oParam);

  CString sampleSourceCode;
  sampleSourceCode += "operator myDeformer($PARAMS) {\n";
  sampleSourceCode += "  result = vec1[index];\n";
  sampleSourceCode += L"}\n";
  
  oCustomProperty.AddParameter(L"SourceCode",CValue::siString,siPersistable,L"",L"",sampleSourceCode,oParam);
	return CStatus::OK;
}

SICALLBACK FESourceCode_DefineLayout( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

  // entry function field
	oLayout.AddItem(L"EntryFunction");

  // source code editor
	oItem = oLayout.AddItem(L"SourceCode", L"SourceCode", siControlTextEditor);
  CStringArray keyWords;
  keyWords.Add(L"Boolean");
  keyWords.Add(L"Integer");
  keyWords.Add(L"Scalar");
  keyWords.Add(L"Byte");
  keyWords.Add(L"Vec3");
  keyWords.Add(L"Quat");
  keyWords.Add(L"in");
  keyWords.Add(L"io");
  keyWords.Add(L"require");
  keyWords.Add(L"operator");
  keyWords.Add(L"if");
  keyWords.Add(L"for");
  keyWords.Add(L"break");
  keyWords.Add(L"continue");
  keyWords.Add(L"while");
  keyWords.Add(L"return");
  keyWords.Add(L"report");
  keyWords.Add(L"alias");
  keyWords.Add(L"switch");
  keyWords.Add(L"else");
  keyWords.Add(L"true");
  keyWords.Add(L"false");
  keyWords.Add(L"case");
  keyWords.Add(L"false");
  keyWords.Add(L"const");
  keyWords.Add(L"function");
  keyWords.Add(L"default");
  keyWords.Add(L"struct");
  keyWords.Add(L"executeParallel");
  CString keyWordStr = keyWords[0];
  for(LONG i=0;i<keyWords.GetCount(); i++)
    keyWordStr += L" " + keyWords[i];
  oItem.PutAttribute( siUIKeywords, keyWordStr );
  oItem.PutAttribute( siUICommentFont, "Verdana" );
  oItem.PutAttribute( siUICommentColor, L"0xFF00FF" );
  oItem.PutAttribute( siUIPreprocessorColor, L"0x808080" );
  oItem.PutAttribute( siUIToolbar, true );
  oItem.PutAttribute( siUICapability, siCanLoad );
  oItem.PutAttribute( siUILineNumbering, true);

  return CStatus::OK;
}

SICALLBACK FESourceCode_Menu_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCallbackItem(L"FESourceCode",L"FESourceCodeMenuClicked",oNewItem);
	return CStatus::OK;
}

SICALLBACK FESourceCodeMenuClicked( XSI::CRef& )
{	
	// We use the AddProp command rather than the C++ API
	// because it logs in the script history and it
	// automatically takes care of different selection possibilities.
	
	Application app;
	CustomProperty prop;

	CValueArray addpropArgs(5) ;
	addpropArgs[0] = L"FESourceCode"; // Type of Property
	addpropArgs[3] = L"FESourceCode"; // Name for the Property

	// At this point you might want to validate what objects
	// are selected to make sure they make sense for your
	// property
	if ( app.GetSelection().GetCount() == 0 )
	{		
		// No selection so create the object at the scene root
		addpropArgs[1] = L"Scene_Root";
	}

	CValue retVal ;
	CStatus st = app.ExecuteCommand( L"SIAddProp", addpropArgs, retVal ) ;

	if ( st.Succeeded() )
	{
		// Inspect newly created Property or Properties
		//(there could be more than one if the selection
		// contains multiple items)
		CValueArray resultArray( (CValueArray&)addpropArgs[4] );
		CValueArray inspectobjArgs(5) ;
		inspectobjArgs[0] = resultArray[0] ;
        
		app.ExecuteCommand( L"InspectObj", inspectobjArgs, retVal ) ;
	}

	return st ;
}
