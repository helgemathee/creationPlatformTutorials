// FEICENode Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Sep 11 15:05:16 UTC+0100 2012 by Helge Mathee
// 
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>
#include <xsi_customproperty.h>
#include <xsi_ppglayout.h>
#include <xsi_menu.h>
#include <xsi_selection.h>
#include <vector>

// Fabric Engine Includes
#include <FabricEngine/Core.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
  ID_IN_entryFunction = 0,
  ID_IN_sourceCode = 1,
  ID_IN_value = 2,
  ID_G_100 = 100,
  ID_G_101 = 101,
  ID_OUT_result = 200,
  ID_OUT_resultVec3 = 201,
  ID_TYPE_CNS = 400,
  ID_STRUCT_CNS,
  ID_CTXT_CNS,
  ID_UNDEF = ULONG_MAX
};

const size_t cNumScalarPorts = 16;

XSI::CStatus Register_FEICENode( XSI::PluginRegistrar& in_reg );

using namespace XSI; 

struct FEICENodeUserData {
  FabricEngine::Core::DGNode resultNode;
  FabricEngine::Core::DGOperator op;
  FabricEngine::Core::DGBinding binding;
  bool valid;
  std::string entryFunction;
  std::string sourceCode;
};

// static attributes
FabricEngine::Core::Client gClient;
std::vector<FabricEngine::Core::DGNode> gValueNodes;
ULONG gInstanceCount = 0;

std::string replaceStdString(std::string input, std::string search, std::string replacement)
{
  std::string::size_type pos = input.find(search, 0); 
  int intLengthSearch = (int)search.length(); 
  int intLengthReplacment = (int)replacement.length(); 

  while(std::string::npos != pos) 
  { 
    input.replace(pos, intLengthSearch, replacement); 
    pos = input.find(search, pos + intLengthReplacment); 
  } 

  return input; 
}

CStatus registerType(std::string name, FEICENodeUserData * usrData, size_t memberCount, const FabricEngine::Core::RTStructMemberInfo * members)
{
  std::string cpDir = getenv("FABRIC_CREATIONPLATFORM_DIR");
  if(cpDir.length() == 0)
  {
    Application().LogMessage(L"Environment variable FABRIC_CREATIONPLATFORM_DIR not defined!", siErrorMsg);
    return CStatus::Unexpected;
  }

  // load the types
  std::string mathDir = cpDir + "\\Python\\SceneGraph\\RT\\Math\\";
  std::string klPath;
  FILE * klFile = NULL;

  // math
  klPath = mathDir + name + ".kl";
  klFile = fopen(klPath.c_str(), "rb");
  if(klFile == NULL)
  {
    std::string message = "KL file for "+name+" not found!";
    Application().LogMessage(message.c_str(), siErrorMsg);
    return CStatus::Unexpected;
  }
  else
  {
    fseek(klFile, 0, SEEK_END);
    size_t size = ftell(klFile);
    rewind(klFile);
    char * sourceCodeChars = (char *)malloc(size+1);
    sourceCodeChars[size] = '\0';
    fread(sourceCodeChars, sizeof(char), size, klFile);
    fclose(klFile);

    std::string sourceCode = replaceStdString(sourceCodeChars, "REPORTWARNINGS", "false");

    try
    {
      FabricEngine::Core::RegisterStruct(
        gClient,
        name.c_str(),
        (uint32_t)memberCount,
        members,
        std::string(name+".kl").c_str(),
        sourceCode.c_str()
      );
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }

    free(sourceCodeChars);
  }

  return CStatus::OK;
}

CStatus initFabricEngineClient(FEICENodeUserData * usrData)
{
  // check if we have the necessary environment variables
  if(gInstanceCount == 0)
  {
    FabricEngine::Core::Initialize();

    // create the client
    gClient = FabricEngine::Core::Client(true);

    // define type members
    FabricEngine::Core::RTStructMemberInfo Vec3Members[3] = {
      { "x", "Float32" },
      { "y", "Float32" },
      { "z", "Float32" }
    };
    FabricEngine::Core::RTStructMemberInfo RotationOrderMembers[1] =
    {
      { "order", "Integer" }
    };
    FabricEngine::Core::RTStructMemberInfo Mat33Members[3] =
    {
      { "row0", "Vec3" },
      { "row1", "Vec3" },
      { "row2", "Vec3" }
    };
    FabricEngine::Core::RTStructMemberInfo EulerMembers[4] =
    {
      { "x", "Scalar" },
      { "y", "Scalar" },
      { "z", "Scalar" },
      { "ro", "RotationOrder" }
    };
    FabricEngine::Core::RTStructMemberInfo QuatMembers[2] =
    {
      { "v", "Vec3" },
      { "w", "Float32" }
    };

    // register all types
    registerType("Math", usrData, 0, NULL);
    registerType("Vec3", usrData, 3, Vec3Members);
    registerType("RotationOrder", usrData, 1, RotationOrderMembers);
    registerType("Mat33", usrData, 3, Mat33Members);
    registerType("Euler", usrData, 4, EulerMembers);
    registerType("Quat", usrData, 2, QuatMembers);

    // create all of the nodes
    for(size_t i=0;i<cNumScalarPorts;i++)
    {
      // create the numbered names
      CString scalarName = L"value"+CString(LONG(i+1));

      // create the nodes
      FabricEngine::Core::DGNode scalarNode(gClient, scalarName.GetAsciiString());

      // define the members on the node
      scalarNode.addMember("data", "Float32");

      // put them into the static arrays
      gValueNodes.push_back(scalarNode);
    }
  }

  // create the result node
  CString nodeName = L"node"+CString(LONG(gInstanceCount));
  usrData->resultNode = FabricEngine::Core::DGNode(gClient, nodeName.GetAsciiString());
  usrData->resultNode.addMember("result", "Scalar");
  usrData->resultNode.addMember("resultVec3", "Vec3");

  // depend on all of the data containers
  for(size_t i=0;i<cNumScalarPorts;i++)
    usrData->resultNode.setDependency(gValueNodes[i].getName().getStdString().c_str(), gValueNodes[i]);

  // create the operator
  usrData->valid = false;
  CString opName = L"operator"+CString(LONG(gInstanceCount));
  usrData->op = FabricEngine::Core::DGOperator(gClient, opName.GetAsciiString());

  // create the parameterlayout
  std::vector<std::string> paramLayoutStr;
  std::vector<const char*> paramLayoutChar;
  paramLayoutStr.push_back("self.index");
  paramLayoutStr.push_back("self.result");
  paramLayoutStr.push_back("self.resultVec3");
  for(size_t i=0;i<cNumScalarPorts;i++)
  {
    CString portName = L"value"+CString((LONG)(i+1))+".data<>";
    paramLayoutStr.push_back(portName.GetAsciiString());
  }
  for(size_t i=0;i<paramLayoutStr.size();i++)
    paramLayoutChar.push_back(paramLayoutStr[i].c_str());

  // create the binding and append it
  FabricEngine::Core::DGBinding binding(
    usrData->op,
    paramLayoutChar.size(),
    &paramLayoutChar[0]
  );
  usrData->binding = binding;
  usrData->resultNode.appendBinding( binding );

  return CStatus::OK;
}

SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
  in_reg.PutAuthor(L"Helge Mathee");
  in_reg.PutName(L"FEICENode Plugin");
  in_reg.PutVersion(1,0);

  Register_FEICENode( in_reg );
	in_reg.RegisterProperty(L"FESourceCode");
	in_reg.RegisterMenu(siMenuTbGetPropertyID,L"FESourceCode_Menu",false,false);

  return CStatus::OK;
}

SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
  CString strPluginName;
  strPluginName = in_reg.GetName();
  Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
  return CStatus::OK;
}

CStatus Register_FEICENode( PluginRegistrar& in_reg )
{
  ICENodeDef nodeDef;
  nodeDef = Application().GetFactory().CreateICENodeDef(L"FEICENode",L"FEICENode");

  CStatus st;
  st = nodeDef.PutColor(73,143,187);
  st.AssertSucceeded( ) ;

  st = nodeDef.PutThreadingModel(XSI::siICENodeSingleThreading);
  st.AssertSucceeded( ) ;

  // Add input ports and groups.
  st = nodeDef.AddPortGroup(ID_G_100);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddPortGroup(ID_G_101, 1, cNumScalarPorts);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_entryFunction,ID_G_100,siICENodeDataString,siICENodeStructureSingle,siICENodeContextSingleton,L"entryFunction",L"entryFunction",CValue(),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_sourceCode,ID_G_100,siICENodeDataString,siICENodeStructureSingle,siICENodeContextSingleton,L"sourceCode",L"sourceCode",CValue(),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  st = nodeDef.AddInputPort(ID_IN_value,ID_G_101,siICENodeDataFloat,siICENodeStructureSingle,siICENodeContextAny,L"value",L"value",0,CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  // Add output ports.
  st = nodeDef.AddOutputPort(ID_OUT_result,siICENodeDataFloat,siICENodeStructureSingle,siICENodeContextComponent0D,L"result",L"result",ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;
  st = nodeDef.AddOutputPort(ID_OUT_resultVec3,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextComponent0D,L"resultVec3",L"resultVec3",ID_UNDEF,ID_UNDEF,ID_UNDEF);
  st.AssertSucceeded( ) ;

  PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
  nodeItem.PutCategories(L"Fabric Engine");

  return CStatus::OK;
}

SICALLBACK FEICENode_Evaluate( ICENodeContext& in_ctxt )
{
  // check if we have a client
  if(gInstanceCount == 0)
    return CStatus::OK;

  // ensure to have a valid userdata
  CValue val = in_ctxt.GetUserData();
  FEICENodeUserData * usrData = (FEICENodeUserData*)(CValue::siPtrType)val;
  if(usrData == NULL)
    return CStatus::OK;

  // check the operator
  std::string entryFunction = CDataArrayString(in_ctxt, ID_IN_entryFunction)[0].GetAsciiString();
  std::string sourceCode = CDataArrayString(in_ctxt, ID_IN_sourceCode)[0].GetAsciiString();
  if(usrData->entryFunction != entryFunction || usrData->sourceCode != sourceCode || !usrData->valid)
  {
    usrData->entryFunction = entryFunction;
    usrData->sourceCode = sourceCode;

    sourceCode = "require Vec3;require Quat;" + sourceCode;

    std::string paramList = "Index index, io Scalar result, io Vec3 resultVec3";
    for(size_t i=0;i<cNumScalarPorts;i++)
    {
      CString scalarName = L", io Scalar value"+CString(LONG(i+1))+L"<>";
      paramList += scalarName.GetAsciiString();
    }
    
    sourceCode = replaceStdString(sourceCode, "$PARAMS", paramList);

    // remove the binding if required
    std::string opName = usrData->op.getName().getStdString()+".kl";
    usrData->op.setFilename(opName.c_str());
    usrData->op.setSourceCode(sourceCode.c_str());
    usrData->op.setEntryPoint(entryFunction.c_str());
    usrData->valid = true;

    // check for errors
    try
    {
      FabricEngine::Core::String errors = usrData->resultNode.getErrors();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Node Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
      errors = usrData->binding.getErrors();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Binding Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
      errors = usrData->op.getErrors();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Operator Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
      errors = usrData->op.getDiagnostics();
      if(errors.isValid())
      {
        Application().LogMessage(L"FE Diagnostic Errors: "+CString(errors.getStdString().c_str()),siErrorMsg);
        usrData->valid = false;
      }
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }
  }

  // ensure we don't run this on empty point clouds
  uint32_t outSize = in_ctxt.GetNumberOfElementsToProcess();
	if(outSize == 0)
		return CStatus::OK;

  // get the number of input data
  ULONG numScalars = 0;
  in_ctxt.GetGroupInstanceCount(ID_G_101, numScalars);

  // copy all scalar value data
  for(ULONG i=0;i<numScalars;i++)
  {
    CDataArrayFloat data( in_ctxt, ID_IN_value, i);
    ULONG inSize = data.IsConstant() ? 1 : data.GetCount();
    if(inSize == 0)
      continue;
    if(gValueNodes[i].getSize() != inSize)
      gValueNodes[i].setSize(inSize);
    gValueNodes[i].setMemberAllSlicesData("data", sizeof(float) * inSize, &data[0]);
  }

  // evaluate the node
  if(usrData->resultNode.getSize() < outSize)
    usrData->resultNode.setSize(outSize);
  if(usrData->valid)
  {
    try
    {
      //FabricEngine::Core::Initialize();
      usrData->resultNode.evaluate();
      //FabricEngine::Core::Finalize();
    }
    catch(FabricEngine::Core::Exception e)
    {
      std::string message = e.getStdString();
      Application().LogMessage(L"FE Exception: "+CString(message.c_str()),siErrorMsg);
      usrData->valid = false;
    }
  }

  // The current output port being evaluated...
  switch( in_ctxt.GetEvaluatedOutputPortID() )
  {    
    case ID_OUT_result :
    {
      // Get the output port array ...      
      CDataArrayFloat outData( in_ctxt );

      // copy the data out
      usrData->resultNode.getMemberAllSlicesData("result", sizeof(float) * outSize, &outData[0]);
    }
    case ID_OUT_resultVec3 :
    {
      // Get the output port array ...      
      CDataArrayVector3f outData( in_ctxt );

      // copy the data out
      usrData->resultNode.getMemberAllSlicesData("resultVec3", sizeof(float) * 3 * outSize, &outData[0]);
    }
    break;
  };
  
  return CStatus::OK;
}

SICALLBACK FEICENode_Init( CRef& in_ctxt )
{
  Context ctxt( in_ctxt );

  // allocate userdata
  FEICENodeUserData * usrData = new FEICENodeUserData();

  // check we have a client
  if(CStatus::OK != initFabricEngineClient(usrData))
    return CStatus::Unexpected;

  CValue val = (CValue::siPtrType) usrData;
  ctxt.PutUserData( val );

  gInstanceCount++;

  return CStatus::OK;
}

SICALLBACK FEICENode_Term( CRef& in_ctxt )
{
  Context ctxt( in_ctxt );

  CValue val = ctxt.GetUserData();
  FEICENodeUserData * usrData = (FEICENodeUserData*)(CValue::siPtrType)val;
  if(usrData != NULL)
    delete(usrData);

  if(gInstanceCount == 1)
  {
    gValueNodes.clear();
    gClient = FabricEngine::Core::Client();
    FabricEngine::Core::Finalize();
  }
  gInstanceCount--;

  return CStatus::OK;
}

SICALLBACK FESourceCode_Define( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

  oCustomProperty.AddParameter(L"EntryFunction",CValue::siString,siPersistable,L"",L"",L"myOperator",oParam);

  CString sampleSourceCode;
  sampleSourceCode += "operator myOperator($PARAMS) {\n";
  sampleSourceCode += "  result = value1[index];\n";
  sampleSourceCode += L"}\n";
  
  oCustomProperty.AddParameter(L"SourceCode",CValue::siString,siPersistable,L"",L"",sampleSourceCode,oParam);
	return CStatus::OK;
}

SICALLBACK FESourceCode_DefineLayout( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

  // entry function field
	oLayout.AddItem(L"EntryFunction");

  // source code editor
	oItem = oLayout.AddItem(L"SourceCode", L"SourceCode", siControlTextEditor);
  CStringArray keyWords;
  keyWords.Add(L"Boolean");
  keyWords.Add(L"Integer");
  keyWords.Add(L"Scalar");
  keyWords.Add(L"Byte");
  keyWords.Add(L"Vec3");
  keyWords.Add(L"Quat");
  keyWords.Add(L"in");
  keyWords.Add(L"io");
  keyWords.Add(L"require");
  keyWords.Add(L"operator");
  keyWords.Add(L"if");
  keyWords.Add(L"for");
  keyWords.Add(L"break");
  keyWords.Add(L"continue");
  keyWords.Add(L"while");
  keyWords.Add(L"return");
  keyWords.Add(L"report");
  keyWords.Add(L"alias");
  keyWords.Add(L"switch");
  keyWords.Add(L"else");
  keyWords.Add(L"true");
  keyWords.Add(L"false");
  keyWords.Add(L"case");
  keyWords.Add(L"false");
  keyWords.Add(L"const");
  keyWords.Add(L"function");
  keyWords.Add(L"default");
  keyWords.Add(L"struct");
  keyWords.Add(L"executeParallel");
  CString keyWordStr = keyWords[0];
  for(LONG i=0;i<keyWords.GetCount(); i++)
    keyWordStr += L" " + keyWords[i];
  oItem.PutAttribute( siUIKeywords, keyWordStr );
  oItem.PutAttribute( siUICommentFont, "Verdana" );
  oItem.PutAttribute( siUICommentColor, L"0xFF00FF" );
  oItem.PutAttribute( siUIPreprocessorColor, L"0x808080" );
  oItem.PutAttribute( siUIToolbar, true );
  oItem.PutAttribute( siUICapability, siCanLoad );
  oItem.PutAttribute( siUILineNumbering, true);

  return CStatus::OK;
}

SICALLBACK FESourceCode_Menu_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCallbackItem(L"FESourceCode",L"FESourceCodeMenuClicked",oNewItem);
	return CStatus::OK;
}

SICALLBACK FESourceCodeMenuClicked( XSI::CRef& )
{	
	// We use the AddProp command rather than the C++ API
	// because it logs in the script history and it
	// automatically takes care of different selection possibilities.
	
	Application app;
	CustomProperty prop;

	CValueArray addpropArgs(5) ;
	addpropArgs[0] = L"FESourceCode"; // Type of Property
	addpropArgs[3] = L"FESourceCode"; // Name for the Property

	// At this point you might want to validate what objects
	// are selected to make sure they make sense for your
	// property
	if ( app.GetSelection().GetCount() == 0 )
	{		
		// No selection so create the object at the scene root
		addpropArgs[1] = L"Scene_Root";
	}

	CValue retVal ;
	CStatus st = app.ExecuteCommand( L"SIAddProp", addpropArgs, retVal ) ;

	if ( st.Succeeded() )
	{
		// Inspect newly created Property or Properties
		//(there could be more than one if the selection
		// contains multiple items)
		CValueArray resultArray( (CValueArray&)addpropArgs[4] );
		CValueArray inspectobjArgs(5) ;
		inspectobjArgs[0] = resultArray[0] ;
        
		app.ExecuteCommand( L"InspectObj", inspectobjArgs, retVal ) ;
	}

	return st ;
}
